(define default-lockfile-name "spkg.lock")
(define lockfile-version 2)

(define-record-type <lock-entry>
  (%lock-entry name type url rev checksum subpath source)
  lock-entry?
  (name lock-entry-name)
  (type lock-entry-type)
  (url lock-entry-url)
  (rev lock-entry-rev)
  (checksum lock-entry-checksum)
  (subpath lock-entry-subpath)
  (source lock-entry-source))

(define (make-lock-entry name type url rev checksum subpath source)
  (%lock-entry name type url rev checksum subpath source))

(define-record-type <lockfile>
  (%lockfile path root-checksum entries)
  lockfile?
  (path lockfile-path)
  (root-checksum lockfile-root-checksum lockfile-root-checksum-set!)
  (entries lockfile-entries lockfile-entries-set!))

(define (make-lockfile path . maybe-root)
  (define root (if (null? maybe-root) #f (car maybe-root)))
  (%lockfile path root '()))

(define (load-lockfile path)
  (cond 
    ((and path (file-exists? path))
      (call-with-input-file path
        (lambda (in)
          (let ((expr (read in)))
            (if (eof-object? expr)
                (make-lockfile path)
                (parse-lockfile path expr))))))
    (else (make-lockfile path))))

(define (save-lockfile! lock)
  (call-with-output-file (lockfile-path lock)
    (lambda (out)
      (pretty-print (lockfile->sexp lock) out)
      (newline out))))

(define (lockfile->sexp lock)
  (let ((entries (map cdr (lockfile-entries lock))))
    (cons 'lockfile
      (append `((version ,lockfile-version)
        ,@(if (lockfile-root-checksum lock)
          `((root-checksum ,(lockfile-root-checksum lock)))
          '()))
      (map lock-entry->sexp entries)))))

(define (lockfile-ref lock name)
  (let ((pair (assoc name (lockfile-entries lock))))
    (and pair (cdr pair))))

(define (lockfile-set-entry! lock entry)
  (define name (lock-entry-name entry))
  (define entries (lockfile-entries lock))
  (define existing (assoc name entries))
  (if existing
      (set-cdr! existing entry)
      (lockfile-entries-set! lock (append entries (list (cons name entry)))))
  entry)

(define (lock-entry->sexp entry)
  (list (lock-entry-type entry)
        (list 'name (lock-entry-name entry))
        (list 'url (lock-entry-url entry))
        (list 'rev (lock-entry-rev entry))
        (list 'checksum (lock-entry-checksum entry))
        (list 'subpath (lock-entry-subpath entry))
        (list 'source (lock-entry-source entry))))

(define (parse-lockfile path expr)
  (unless (and (pair? expr) (symbol? (car expr)) (eq? (car expr) 'lockfile))
    (error "Invalid lockfile root" expr))
  (let ((lock (make-lockfile path)))
    (define version-seen #f)
    (let loop ((rest (cdr expr)))
      (cond
        ((null? rest)
         (when (and version-seen (not (or (= version-seen 1) (= version-seen lockfile-version))))
           (error "Unsupported lockfile version" version-seen))
         lock)
        ((and (pair? (car rest)) (symbol? (caar rest)) (eq? (caar rest) 'version))
         (let ((v (cadar rest)))
           (unless (integer? v)
             (error "Invalid lockfile version" v))
           (set! version-seen v)
           (loop (cdr rest))))
        ((and (pair? (car rest)) (symbol? (caar rest)) (eq? (caar rest) 'root-checksum))
         (let ((root (cadar rest)))
           (unless (or (not root) (string? root))
             (error "Invalid lockfile root checksum" root))
           (lockfile-root-checksum-set! lock root)
           (loop (cdr rest))))
        (else
          (lockfile-set-entry! lock (parse-lock-entry (car rest)))
          (loop (cdr rest)))))))

(define (parse-lock-entry expr)
  (unless (and (pair? expr) (symbol? (car expr)))
    (error "Invalid lockfile entry" expr))
  (let* ((entry-type (car expr))
         (fields (cdr expr))
         (alist (map lockfile-field->pair fields))
         (name (lockfile-field-ref 'name alist #f))
         (url (lockfile-field-ref 'url alist #f))
         (rev (lockfile-field-ref 'rev alist #f))
         (checksum (lockfile-field-ref 'checksum alist #f))
         (subpath (lockfile-field-ref 'subpath alist #f))
         (source (lockfile-field-ref 'source alist #f)))
    (unless (or (symbol? name) (list? name))
      (error "Lockfile entry missing name" expr))
    (unless (string? url)
      (error "Lockfile entry missing url" expr))
    (unless (string? checksum)
      (error "Lockfile entry missing checksum" expr))
    (unless (or (not source) (string? source))
      (error "Invalid lockfile source" expr))
    (unless (or (not rev) (string? rev))
      (error "Invalid lockfile rev value" rev))
    (unless (or (not subpath) (string? subpath))
      (error "Invalid lockfile subpath value" subpath))
    (make-lock-entry name entry-type url rev checksum subpath source)))

(define (lockfile-field->pair field)
  (unless (and (pair? field) (pair? (cdr field)) (null? (cddr field)))
    (error "Invalid lockfile field" field))
  (cons (car field) (cadr field)))

(define (lockfile-field-ref key alist default)
  (let ((pair (assoc key alist)))
    (if pair (cdr pair) default)))
